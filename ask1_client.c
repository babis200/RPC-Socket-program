/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ask1.h"
#include <pthread.h>	//χρηση thread για δυνατότητα πολων χρηστών


struct arg_struct {		//χρησημοποιώντας την arg_struct τρέχω από το thread την ask1_prog1_1
    char * hostname;	// συνήθως localhost
    int client_name;
};

void
ask1_prog1_1(void *arguments)
{
	struct arg_struct *args = arguments;
	CLIENT *clnt;
	float  *result_1;			//εδώ αποθηκευεται το αποτέλεσμα της 1ης λειτουργίας
	X_array  metre_1_arg;
	int  *result_2;				//εδώ αποθηκευεται το αποτέλεσμα της 2ης λειτουργίας
	XY_array  inner_product_1_arg;
	float  *result_3;			//εδώ αποθηκευεται η μέση τιμή του Χ
	X_array  averagex_1_arg;
	float  *result_4;			//εδώ αποθηκευεται η μέση τιμή του Υ
	Y_array  averagey_1_arg;
	rXY  *result_5;				//εδώ αποθηκευεται το αποτέλεσμα της 4ης λειτουργίας
	r_times_X_Y  product_1_arg;

#ifndef	DEBUG
	clnt = clnt_create ((char *)args->hostname, ASK1_PROG1, ASK1_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (args->hostname);
		exit (1);
	}
#endif	/* DEBUG */

	int flag=1;	//όταν flag == 0 κλείνει το πρόγραμμα
	int choice;
	int i;
	int n;
	float r;	
	int *X, *Y;		//διανύσματα Χ και Υ
	int client=(int) args->client_name;	//όνομα socket client
	
	do
	{
		recv(client,&choice,sizeof(int),0);	//λάβε την επιλογή λειτουργίας από τον socket client
		
		printf("Choice from client: %d \n", choice);
		
		if(choice==1)		
		{
			
			//metre of X[]
			
			recv(client,&n,sizeof(int),0);	//λάβε μέγεθος διανύσματος Χ
		
			metre_1_arg.X.X_len=n;			//πέρνα το μέγεθος για τον rpc_server
			metre_1_arg.X_size=n;
			metre_1_arg.X.X_val=(int *) malloc(n*sizeof(int));
			X = (int *) malloc(n*sizeof(int));
			
			recv(client,X,n*sizeof(int),0);  //λάβε το διάνυσμα Χ
			
			for(i=0;i<n;i++)
			{
				metre_1_arg.X.X_val[i] = X[i];	//πέρνα το Χ για τον rpc_server
			}
	
			result_1 = metre_1(&metre_1_arg, clnt);		//κάνει πράξεις στον rpc_server
			
			if (result_1 == (float *) NULL) 			//τσεκάρει αμα πέτυχε το call
			{
				clnt_perror (clnt, "call failed");
			}
			else
			{
				send(client,result_1,sizeof(float),0);	//στείλε τα αποτέσματα στον socket client
			}
			
		}
		else if(choice==2)
		{
			
			//inner product of X[] and Y[]
			
			recv(client,&n,sizeof(int),0);		//λάβε μέγεθος διανύσματος Χ
			
			inner_product_1_arg.XY.XY_len=n;	//πέρνα το μέγεθος για τον rpc_server
			inner_product_1_arg.XY_size=n;
			inner_product_1_arg.XY.XY_val=(int *) malloc(n*sizeof(int));
			X = (int *) malloc(n*sizeof(int));
			
			recv(client,X,n*sizeof(int),0);		//λάβε το διάνυσμα Χ
			
			for(i=0;i<n;i++)
			{
				inner_product_1_arg.XY.XY_val[i] = X[i];	//πέρνα το Χ για τον rpc_server
			}
						
			result_2 = inner_product_1(&inner_product_1_arg, clnt);		//υπολογίζει εσωτερικό γινόμενο των δύο διανυσμάτων στον rpc_server
			
			if (result_2 == (int *) NULL) 					//τσεκάρει αμα πέτυχε το call
			{
				clnt_perror (clnt, "call failed");
			}
			else
			{
				send(client,result_2,sizeof(int),0);		//στείλε τα αποτέσματα στον socket client
			}
			
		}		
		else if(choice==3)	
		{
			
			//average of X[] and Y[]
			
			recv(client,&n,sizeof(int),0);		//λάβε μέγεθος διανύσματος Χ και Υ
			
			averagex_1_arg.X.X_len=n;			//πέρνα το μέγεθος Χ για τον rpc_server
			averagex_1_arg.X_size=n;
			averagex_1_arg.X.X_val=(int *) malloc(n*sizeof(int));
			X = (int *) malloc(n*sizeof(int));
			
			averagey_1_arg.Y.Y_len=n;			//πέρνα το μέγεθος του Υ για τον rpc_server
			averagey_1_arg.Y_size=n;
			averagey_1_arg.Y.Y_val=(int *) malloc(n*sizeof(int));
			Y = (int *) malloc(n*sizeof(int));
			
			recv(client,X,n*sizeof(int),0);		//λάβε το διάνυσμα Χ
			recv(client,Y,n*sizeof(int),0);		//λάβε το διάνυσμα Υ
			
			for(i=0;i<n;i++)
			{
				averagex_1_arg.X.X_val[i] = X[i];			//πέρνα το Χ για τον rpc_server
			}
			
			for(i=0;i<n;i++)
			{
				averagey_1_arg.Y.Y_val[i] = Y[i];			//πέρνα το Υ για τον rpc_server	
			}
				
			result_3 = averagex_1(&averagex_1_arg, clnt);		//υπολογίζει μέση τιμή Χ στον rpc_server
			result_4 = averagey_1(&averagey_1_arg, clnt);		//υπολογίζει μέση τιμή Υ στον rpc_server
			
			if (result_3 == (float *) NULL || result_4 == (float *) NULL) 	//τσεκάρει άμα πέτυχαν τα call
			{
				clnt_perror (clnt, "call failed");
			}
			else
			{
				send(client,result_3,sizeof(float),0);		//στείλε τα αποτέσματα στον socket client
				send(client,result_4,sizeof(float),0);		//στείλε τα αποτέσματα στον socket client
			}
			
		}
		else if (choice==4)
		{
			//r*(X[]+Y[])
			
			recv(client,&n,sizeof(int),0);		//λάβε μέγεθος διανύσματος Χ και Υ
		
			product_1_arg.X_Y.X_Y_len=n;		//πέρνα το μέγεθος Χ και Υ για τον rpc_server
			product_1_arg.X_Y_size=n;
			product_1_arg.X_Y.X_Y_val=(int *) malloc(n*sizeof(int));
			X = (int *) malloc(n*sizeof(int));
			
			recv(client,X,n*sizeof(int),0);		//λάβε το Χ+Υ
			
			for(i=0;i<n;i++)
			{
				product_1_arg.X_Y.X_Y_val[i] = X[i];		//πέρνα το Χ+Υ για τον rpc_server	
			}
			
			recv(client,&r,sizeof(float),0);		//λάβε το ρ
			
			product_1_arg.r=r;						//πέρνα το ρ για τον rpc_server
			
			result_5 = product_1(&product_1_arg, clnt);		//υπολογίζει ρ*Χ+Υ
			
			if (result_5 == (rXY *) NULL) 
			{
				clnt_perror (clnt, "call failed");		//τσεκάρει άμα πέτυχε το call
			}
			else
			{
				send(client,result_5->prod.prod_val,n*sizeof(float),0);	//στείλε τα αποτέσματα στον socket client
			}
		}
		else if(choice==5)	//έξοδος
		{
			flag=0;
		}
		else
		{
			printf("Invalid Choice. Try Again.\n\n");
		}
	}while(flag);
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}




int
main (int argc, char *argv[])
{
	struct arg_struct arguments;	// arguments for passing in thread
	int input_socket;
	int accepted_socket;
	int portno;
	int clilen;
	int i=0;
	
	struct sockaddr_in serv_addr;
	struct sockaddr_in cli_addr;
	
	
	pthread_t thread[50];
	
	if (argc < 3) {		//πρότυπο χρήσης
        printf("usage %s hostname port\n", argv[0]);
        exit(1);
    }
	
	//προετοιμασία socket
	
	input_socket = socket(AF_INET, SOCK_STREAM, 0);	
	
	bzero((char *) &serv_addr, sizeof(serv_addr));
	
	
	portno = atoi(argv[2]);
	
	serv_addr.sin_family=AF_INET;
	serv_addr.sin_port=htons(portno);
	serv_addr.sin_addr.s_addr=INADDR_ANY;
	
	bind(input_socket, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
	
	listen(input_socket,5);
	
	
	while(1)
	{
		
		printf("Waiting for connection...\n");
		clilen=sizeof(cli_addr);
		accepted_socket=accept(input_socket, (struct sockaddr *) &cli_addr, &clilen);	//εισοδος νεου client
		
		arguments.client_name = accepted_socket;
		arguments.hostname = argv[1];
		
		pthread_create(&(thread[i++]), NULL, (void *)ask1_prog1_1, (void *) &arguments);	//καλεσμα μεσω thread της ask1_prog1_1
	}


	return 0;
	
	exit (0);
}
